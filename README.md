# Лабораторная работа №1
---
**Выполнила:** Логинова Ольга Олеговна 
**Группа:** Р3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure

---

### [Задача 7](https://projecteuler.net/problem=7)  
**Найти 10 001-ое простое число**

---

## Реализации

- **solve-7-tail**  
  Монолитная реализация с **хвостовой рекурсией** (`loop/recur`).  
  На каждой итерации проверяется очередное число на простоту, счётчик найденных простых увеличивается до тех пор, пока не будет найдено 10 001 простое.  
  Такой подход эффективен по памяти за счёт оптимизации хвостовой рекурсии.

- **solve-7-recursive**  
  Обычная рекурсия без хвостовой оптимизации.  
  Функция вызывает сама себя до тех пор, пока не будет найден нужный результат.  
  Подходит для понимания идеи рекурсии, но менее устойчива для больших чисел (риск переполнения стека).

- **solve-7-modular**  
  Разделение задачи на отдельные этапы:
  - генерация последовательности чисел (`range`),
  - фильтрация с помощью `prime?`,
  - выбор `nth` для получения нужного простого.  
  Такой стиль показывает **модульность** и разделение ответственности.

- **solve-7-map**  
  Использование `map` и фильтрации.  
  Генерируются натуральные числа функцией `iterate`, затем фильтруются простые.  
  Подход подчеркивает использование **функций высшего порядка**.

- **solve-7-loop**  
  Явная реализация через цикл `loop/recur`.  
  По сути аналог хвостовой рекурсии, но запись ближе к привычному циклу.  
  Наглядно демонстрирует императивный стиль в функциональном языке.

- **solve-7-lazy**  
  Использование **ленивых последовательностей**.  
  Строится бесконечный поток натуральных чисел, фильтруется функцией `prime?`, затем выбирается `nth`.  
  Такой способ удобен, так как не требует заранее задавать границы.

- **solve-7-sieve**  
  Реализация **решета Эратосфена** в ленивой форме.  
  Последовательно исключаются кратные найденных простых.  
  Это наглядный пример работы с `lazy-seq` и рекурсивным построением бесконечной последовательности.

---

### [Задача 24](https://projecteuler.net/problem=24)  
**Найти миллионную лексикографическую перестановку чисел 0–9**

---

## Реализации

- **solve-24**  
  Аналитический метод.  
  Используются факториалы для определения того, в какой блок перестановок попадает нужное число.  
  На каждом шаге берётся элемент с индексом `k // (m-1)!`, после чего задача решается для оставшихся элементов и остатка `k mod (m-1)!`.  
  Это быстрый и точный алгоритм.

- **solve-24-tail**  
  Хвосторекурсивная версия аналитического метода.  
  Используется `loop/recur`, чтобы пошагово строить результат без риска переполнения стека.  
  Каждое число выбирается и добавляется в аккумулятор, пока список не станет пустым.

- **solve-24-bruteforce**  
  Полный перебор перестановок (через рекурсию и `for`).  
  Возвращается ленивая последовательность всех перестановок, затем берётся миллионная.  
  Это самый простой, но **очень неэффективный** способ (для проверки корректности).

- **millionth-permutation** (модуль `problem24-alt`)  
  Компактный вариант аналитического метода.  
  Здесь также используется идея деления на факториалы, но реализация более минималистичная и функциональная.  

---

## Выводы

В данной лабораторной работе я:

- реализовала решения одной и той же задачи несколькими способами;
- сравнила подходы: хвостовая рекурсия, обычная рекурсия, ленивые последовательности, модульный стиль;
- закрепила работу с `map`, `filter`, `reduce`, `loop/recur`, `lazy-seq`;
- убедилась, что разные стили программирования дают одинаковый результат:  
  - Задача 7: **104743**  
  - Задача 24: **2783915460**

---

